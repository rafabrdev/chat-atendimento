name: Deploy Pipeline

on:
  push:
    branches:
      - develop
      - staging
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '18'

jobs:
  # ==================== TEST JOB ====================
  test:
    name: Test & Lint
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Install Backend Dependencies
        working-directory: ./backend
        run: npm ci
      
      - name: Install Frontend Dependencies  
        working-directory: ./frontend
        run: npm ci
      
      - name: Run Backend Lint
        working-directory: ./backend
        run: npm run lint --if-present || true
      
      - name: Run Frontend Lint
        working-directory: ./frontend
        run: npm run lint --if-present || true
      
      - name: Run Backend Tests
        working-directory: ./backend
        run: npm test --if-present || echo "No tests configured"
      
      - name: Run Frontend Tests
        working-directory: ./frontend
        run: npm test --if-present -- --passWithNoTests || echo "No tests configured"

  # ==================== BUILD JOB ====================
  build:
    name: Build Application
    needs: test
    runs-on: ubuntu-latest
    
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=development" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
          fi
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Build Backend
        working-directory: ./backend
        env:
          NODE_ENV: ${{ steps.determine-env.outputs.environment }}
        run: |
          npm ci
          echo "‚úÖ Backend build completed for ${{ steps.determine-env.outputs.environment }}"
      
      - name: Build Frontend
        working-directory: ./frontend
        env:
          NODE_ENV: ${{ steps.determine-env.outputs.environment }}
          GENERATE_SOURCEMAP: ${{ steps.determine-env.outputs.environment == 'production' && 'false' || 'true' }}
        run: |
          npm ci
          npm run build
          echo "‚úÖ Frontend build completed for ${{ steps.determine-env.outputs.environment }}"
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-${{ steps.determine-env.outputs.environment }}
          path: |
            backend/
            frontend/dist/
            docker-compose*.yml
          retention-days: 7

  # ==================== DEPLOY DEVELOPMENT ====================
  deploy-development:
    name: Deploy to Development
    needs: build
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    environment:
      name: development
      url: http://localhost:3000
    
    steps:
      - name: Development Info
        run: |
          echo "üì¶ Development build completed!"
          echo "This is a local development branch."
          echo ""
          echo "To run locally:"
          echo "1. Pull latest changes: git pull origin develop"
          echo "2. Start backend: cd backend && npm run dev"
          echo "3. Start frontend: cd frontend && npm run dev"
          echo ""
          echo "Or use Docker:"
          echo "docker-compose -f docker-compose.dev.yml up -d"

  # ==================== DEPLOY STAGING ====================
  deploy-staging:
    name: Deploy to Staging
    needs: build
    if: github.ref == 'refs/heads/staging'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: http://52.90.17.204:3001
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Deploy to EC2 Staging
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER || 'ec2-user' }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME_STAGING: ${{ secrets.S3_BUCKET_NAME_STAGING }}
        run: |
          # Save SSH key
          echo "$EC2_SSH_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          # Deploy via SSH with environment variables
          ssh -o StrictHostKeyChecking=no -i private_key.pem ${EC2_USER}@${EC2_HOST} << 'ENDSSH'
            # Ensure Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo yum update -y
              sudo yum install -y docker git
              sudo service docker start
              sudo usermod -a -G docker \$USER
              
              # Install Docker Compose
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            # Clone or update repository
            if [ ! -d ~/chat-atendimento ]; then
              git clone https://github.com/rafabrdev/chat-atendimento.git ~/chat-atendimento
            fi
            
            cd ~/chat-atendimento
            git fetch origin
            git checkout staging
            git pull origin staging
            
            # Create backend .env file
            cat > backend/.env <<-ENVFILE
            NODE_ENV=staging
            PORT=3001
            MONGODB_URI='${MONGODB_URI}'
            JWT_SECRET='${JWT_SECRET}'
            AWS_ACCESS_KEY_ID='${AWS_ACCESS_KEY_ID}'
            AWS_SECRET_ACCESS_KEY='${AWS_SECRET_ACCESS_KEY}'
            S3_BUCKET_NAME='${S3_BUCKET_NAME_STAGING}'
            AWS_REGION=us-east-1
            CLIENT_URL=http://${EC2_HOST}:3000
            ENVFILE
            
            # Create frontend .env file
            cat > frontend/.env <<-ENVFILE2
            VITE_API_URL=http://${EC2_HOST}:3001/api
            VITE_SOCKET_URL=http://${EC2_HOST}:3001
            ENVFILE2
            
            # Stop existing containers
            docker-compose down || true
            
            # Start services
            docker-compose -f docker-staging.yml up -d --build
            
            # Clean old images
            docker image prune -f
            
            echo "‚úÖ Staging deployment complete!"
          ENDSSH
          
          # Clean up
          rm private_key.pem
      
      - name: Health Check
        run: |
          sleep 20
          response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.EC2_HOST }}:3001/health || echo "000")
          if [ "$response" = "200" ]; then
            echo "‚úÖ Staging API is healthy!"
          else
            echo "‚ö†Ô∏è API returned code: $response"
            exit 1
          fi

  # ==================== DEPLOY PRODUCTION ====================
  deploy-production:
    name: Deploy to Production
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://suporte.brsi.net.br
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Backup current deployment
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER || 'ec2-user' }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          echo "$EC2_SSH_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          ssh -o StrictHostKeyChecking=no -i private_key.pem ${EC2_USER}@${EC2_HOST} << 'ENDSSH'
            if [ -d ~/chat-atendimento ]; then
              cp -r ~/chat-atendimento ~/chat-atendimento-backup-$(date +%Y%m%d-%H%M%S)
              echo "‚úÖ Backup created"
            fi
          ENDSSH
          
          rm private_key.pem
      
      - name: Deploy to EC2 Production
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER || 'ec2-user' }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          MONGODB_URI_PROD: ${{ secrets.MONGODB_URI_PROD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME_PRODUCTION: ${{ secrets.S3_BUCKET_NAME_PRODUCTION }}
        run: |
          echo "$EC2_SSH_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          ssh -o StrictHostKeyChecking=no -i private_key.pem ${EC2_USER}@${EC2_HOST} << 'ENDSSH'
            # Update repository
            cd ~/chat-atendimento
            git fetch origin
            git checkout main
            git pull origin main
            
            # Create production .env files
            cat > backend/.env <<-ENVFILE
            NODE_ENV=production
            PORT=3002
            MONGODB_URI='${MONGODB_URI_PROD}'
            JWT_SECRET='${JWT_SECRET}'
            AWS_ACCESS_KEY_ID='${AWS_ACCESS_KEY_ID}'
            AWS_SECRET_ACCESS_KEY='${AWS_SECRET_ACCESS_KEY}'
            S3_BUCKET_NAME='${S3_BUCKET_NAME_PRODUCTION}'
            AWS_REGION=us-east-1
            CLIENT_URL=https://suporte.brsi.net.br
            ENVFILE
            
            # Create frontend .env file
            cat > frontend/.env <<-ENVFILE2
            VITE_API_URL=http://${EC2_HOST}:3002/api
            VITE_SOCKET_URL=http://${EC2_HOST}:3002
            ENVFILE2
            
            # Deploy with zero downtime
            docker-compose -f docker-production.yml up -d --build
            
            # Clean old images
            docker image prune -f
            
            echo "‚úÖ Production deployment complete!"
          ENDSSH
          
          rm private_key.pem
      
      - name: Production Health Check
        run: |
          sleep 30
          # Check if domain is configured
          if curl -s -o /dev/null -w "%{http_code}" https://suporte.brsi.net.br/health | grep -q "200"; then
            echo "‚úÖ Production API is healthy (HTTPS)!"
          elif curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.EC2_HOST }}:3002/health | grep -q "200"; then
            echo "‚ö†Ô∏è API is healthy on HTTP only. Configure SSL/HTTPS!"
          else
            echo "‚ùå Production API health check failed!"
            exit 1
          fi
      
      - name: Create Release
        if: success()
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Production Release v${{ github.run_number }}
          body: |
            ## Production Deployment
            - **Commit**: ${{ github.sha }}
            - **Deployed by**: ${{ github.actor }}
            - **Date**: ${{ github.event.head_commit.timestamp }}
          draft: false
          prerelease: false

  # ==================== ROLLBACK (IF NEEDED) ====================
  rollback:
    name: Rollback Production
    needs: deploy-production
    if: failure() && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
      - name: Rollback to previous version
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER || 'ec2-user' }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          echo "$EC2_SSH_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          ssh -o StrictHostKeyChecking=no -i private_key.pem ${EC2_USER}@${EC2_HOST} << 'ENDSSH'
            cd ~/chat-atendimento
            
            # Stop current deployment
            docker-compose -f docker-production.yml down
            
            # Restore backup
            LATEST_BACKUP=$(ls -t ~/chat-atendimento-backup-* 2>/dev/null | head -1)
            if [ -n "$LATEST_BACKUP" ]; then
              echo "Rolling back to $LATEST_BACKUP"
              rm -rf ~/chat-atendimento
              mv "$LATEST_BACKUP" ~/chat-atendimento
              cd ~/chat-atendimento
              docker-compose -f docker-production.yml up -d
              echo "‚úÖ Rollback completed"
            else
              echo "‚ùå No backup found for rollback"
              exit 1
            fi
          ENDSSH
          
          rm private_key.pem
      
      - name: Notify rollback
        run: |
          echo "‚ö†Ô∏è Production deployment failed and was rolled back!"
          echo "Please investigate the issue before attempting another deployment."
